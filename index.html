<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - instancing test (single triangle)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0;
			background-color: #000;
			color: #fff;
			font-family: Monospace;
			font-size: 13px;
			line-height: 24px;
			overscroll-behavior: none;
		}

		a {
			color: #ff0;
			text-decoration: none;
		}

		a:hover {
			text-decoration: underline;
		}

		#container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 10px;
			box-sizing: border-box;
			text-align: center;
			-moz-user-select: none;
			-webkit-user-select: none;
			-ms-user-select: none;
			user-select: none;
			pointer-events: none;
			z-index: 1;
		}
	</style>
</head>
<body>

	<div id="container"></div>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - instancing demo (single triangle)
		<div id="notSupported" style="display:none">Sorry your graphics card + browser does not support hardware instancing</div>
	</div>

	<script id="vertexShader" type="x-shader/x-vertex">
		precision highp float;

		uniform float sineTime;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec3 offset;
		attribute vec4 color;
		attribute vec4 orientationStart;
		attribute vec4 orientationEnd;

		varying vec3 vPosition;
		varying vec4 vColor;

		void main(){

			vPosition = offset * max( abs( sineTime * 2.0 + 1.0 ), 0.5 ) + position;
			vec4 orientation = normalize( mix( orientationStart, orientationEnd, sineTime ) );
			vec3 vcV = cross( orientation.xyz, vPosition );
			vPosition = vcV * ( 2.0 * orientation.w ) + ( cross( orientation.xyz, vcV ) * 2.0 + vPosition );

			vColor = color;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );

		}
	</script>

	<script id="fragmentShader" type="x-shader/x-fragment">
		precision highp float;

		uniform float time;

		varying vec3 vPosition;
		varying vec4 vColor;

		void main() {

			vec4 color = vec4( vColor );
			color.r += sin( vPosition.x * 10.0 + time ) * 0.5;

			gl_FragColor = color;

		}
	</script>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.min.js"></script>

	<script>
		let container, stats;
		let camera, scene, renderer;

		init();

		function init() {
			container = document.getElementById('container');

			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10);
			camera.position.z = 2;

			scene = new THREE.Scene();

			// geometry
			const vector = new THREE.Vector4();
			const instances = 50000;

			const positions = [];
			const offsets = [];
			const colors = [];
			const orientationsStart = [];
			const orientationsEnd = [];

			positions.push(0.025, -0.025, 0);
			positions.push(-0.025, 0.025, 0);
			positions.push(0, 0, 0.025);

			// instanced attributes
			for (let i = 0; i < instances; i++) {
				// offsets
				offsets.push(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);

				// colors
				colors.push(Math.random(), Math.random(), Math.random(), Math.random());

				// orientation start
				vector.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
				vector.normalize();
				orientationsStart.push(vector.x, vector.y, vector.z, vector.w);

				// orientation end
				vector.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
				vector.normalize();
				orientationsEnd.push(vector.x, vector.y, vector.z, vector.w);
			}

			const geometry = new THREE.InstancedBufferGeometry();
			geometry.instanceCount = instances; // set so its initialized for dat.GUI, will be set in first draw otherwise

			geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
			geometry.setAttribute('offset', new THREE.InstancedBufferAttribute(new Float32Array(offsets), 3));
			geometry.setAttribute('color', new THREE.InstancedBufferAttribute(new Float32Array(colors), 4));
			geometry.setAttribute('orientationStart', new THREE.InstancedBufferAttribute(new Float32Array(orientationsStart), 4));
			geometry.setAttribute('orientationEnd', new THREE.InstancedBufferAttribute(new Float32Array(orientationsEnd), 4));

			// material
			const material = new THREE.RawShaderMaterial({
				uniforms: {
					'time': { value: 1.0 },
					'sineTime': { value: 1.0 }
				},
				vertexShader: document.getElementById('vertexShader').textContent,
				fragmentShader: document.getElementById('fragmentShader').textContent,
				side: THREE.DoubleSide,
				transparent: true
			});

			const mesh = new THREE.Mesh(geometry, material);
			scene.add(mesh);

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			// Create a simple control for instance count
			const countControl = document.createElement('div');
			countControl.style.position = 'absolute';
			countControl.style.bottom = '10px';
			countControl.style.left = '10px';
			countControl.style.zIndex = '100';
			countControl.style.backgroundColor = 'rgba(0,0,0,0.5)';
			countControl.style.padding = '10px';
			countControl.style.borderRadius = '5px';
			countControl.style.pointerEvents = 'auto';
			
			const slider = document.createElement('input');
			slider.type = 'range';
			slider.min = '0';
			slider.max = instances.toString();
			slider.value = instances.toString();
			slider.style.width = '200px';
			slider.addEventListener('input', function() {
				geometry.instanceCount = parseInt(this.value);
				countLabel.textContent = 'Instances: ' + this.value;
			});
			
			const countLabel = document.createElement('div');
			countLabel.textContent = 'Instances: ' + instances;
			countLabel.style.marginBottom = '5px';
			
			countControl.appendChild(countLabel);
			countControl.appendChild(slider);
			container.appendChild(countControl);

			// Stats panel - simple custom implementation
			const statsPanel = document.createElement('div');
			statsPanel.style.position = 'absolute';
			statsPanel.style.top = '0px';
			statsPanel.style.right = '0px';
			statsPanel.style.zIndex = '100';
			statsPanel.style.backgroundColor = 'rgba(0,0,0,0.5)';
			statsPanel.style.padding = '10px';
			statsPanel.style.color = '#0ff';
			statsPanel.style.fontFamily = 'monospace';
			statsPanel.style.fontSize = '12px';
			statsPanel.style.pointerEvents = 'none';
			container.appendChild(statsPanel);
			
			let frameCount = 0;
			let lastTime = performance.now();
			let fps = 0;
			
			function updateStats() {
				frameCount++;
				const now = performance.now();
				const delta = now - lastTime;
				
				if (delta >= 1000) {
					fps = Math.round((frameCount * 1000) / delta);
					frameCount = 0;
					lastTime = now;
					statsPanel.textContent = fps + ' FPS';
				}
				
				requestAnimationFrame(updateStats);
			}
			
			updateStats();

			window.addEventListener('resize', onWindowResize);
			
			// Start animation
			animate();
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			requestAnimationFrame(animate);
			
			const time = performance.now();
			const object = scene.children[0];

			object.rotation.y = time * 0.0005;
			object.material.uniforms['time'].value = time * 0.005;
			object.material.uniforms['sineTime'].value = Math.sin(object.material.uniforms['time'].value * 0.05);

			renderer.render(scene, camera);
		}
	</script>
</body>
</html>